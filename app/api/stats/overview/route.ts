import { NextResponse } from "next/server";
import type { StatsSourceKey } from "@/lib/googleStats";
import { tryDecryptToken } from "@/lib/oauthCrypto";
function asRecord(v: unknown): Record<string, unknown> {
  return v && typeof v === "object" && !Array.isArray(v) ? (v as Record<string, unknown>) : {};
}

// NOTE: We lazy-import internal libs inside the handler to avoid returning an HTML error page
// when a dependency throws at module-evaluation time (e.g. cookies()/headers() scope issues).

function safeJsonParse<T>(s: unknown, fallback: T): T {
  if (!s) return fallback;
  try {
    if (typeof s === "string") return JSON.parse(s) as T;
    return s as T;
  } catch {
    return fallback;
  }
}

type SiteConn = { ga4: boolean; gsc: boolean };

type SourcesStatus = {
  site_inrcy: { connected: SiteConn };
  site_web: { connected: SiteConn };
  gmb: { connected: boolean; metrics: unknown | null };
  facebook: { connected: boolean; metrics: unknown | null };
  instagram: { connected: boolean; metrics: unknown | null };
  linkedin: { connected: boolean; metrics: unknown | null };
};

type SocialSnapshot = {
  gmb: { connected: boolean; metrics: unknown | null };
  facebook: { connected: boolean };
  instagram: { connected: boolean };
  linkedin: { connected: boolean };
};

type SiteSettings = {
  ga4?: { property_id?: string; measurement_id?: string };
  gsc?: { property?: string };
  site_web?: {
    ga4?: { property_id?: string; measurement_id?: string };
    gsc?: { property?: string };
  };
};

function _sumMap<K extends string>(items: Array<{ key: K; value: number }>) {
  const m = new Map<K, number>();
  for (const it of items) m.set(it.key, (m.get(it.key) || 0) + it.value);
  return m;
}

export async function GET(request: Request) {
  try {
    // Lazy-import server helpers inside the request scope to avoid Next.js request-scope errors.
    const { createSupabaseServer } = await import("@/lib/supabaseServer");
    const {
      getGoogleTokenFor,
      runGa4Report,
      runGa4TopPages,
      runGa4Channels,
      runGscQuery,
      getGoogleTokenForAnyGoogle,
    } = await import("@/lib/googleStats");
    const { gmbFetchDailyMetrics } = await import("@/lib/googleBusiness");
    const { igFetchDailyInsights } = await import("@/lib/metaInsights");
    const { fbFetchDailyInsights } = await import("@/lib/facebookInsights");
    const { liFetchOrgShareStats } = await import("@/lib/linkedinAnalytics");

    const { searchParams } = new URL(request.url);
    const days = Math.min(Math.max(Number(searchParams.get("days") || 28), 7), 90);

    // Optional: filter which sources to aggregate.
    // Comma-separated keys:
    // - site_inrcy_ga4, site_inrcy_gsc
    // - site_web_ga4,  site_web_gsc
    // - gmb, facebook
    const includeRaw = (searchParams.get("include") || "").trim();
    const includeSet = new Set(
      includeRaw
        ? includeRaw
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean)
        : []
    );
    const includeAll = includeSet.size === 0;

    const supabase = await createSupabaseServer();
    const { data: authData, error: authErr } = await supabase.auth.getUser();
    if (authErr || !authData?.user) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }
    const userId = authData.user.id;


    // --- Social connection snapshot (always computed live) ---
    // IMPORTANT: iNrStats calls the same overview endpoint with different `include=` values.
    // If we return a cached payload generated by an older version (or without social keys),
    // the UI can incorrectly show "Déconnecté" even when integrations are connected.
    // So we always (re)hydrate social connection flags from `integrations` before returning.
    async function fetchSocialStatus() {
      const out: SocialSnapshot = {
        gmb: { connected: false, metrics: null },
        facebook: { connected: false },
        instagram: { connected: false },
        linkedin: { connected: false },
      };

      // Facebook
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status")
          .eq("user_id", userId)
          .eq("provider", "facebook")
          .eq("source", "facebook")
          .eq("product", "facebook")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.facebook.connected = !!(data as unknown[])?.[0];
      } catch {}

      // Instagram (requires profile selection => resource_id)
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status,resource_id")
          .eq("user_id", userId)
          .eq("provider", "instagram")
          .eq("source", "instagram")
          .eq("product", "instagram")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        const ig0 = Array.isArray(data) ? (data as unknown[])[0] : null;
        out.instagram.connected = !!asRecord(ig0)["resource_id"];
      } catch {}

      // LinkedIn
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status")
          .eq("user_id", userId)
          .eq("provider", "linkedin")
          .eq("source", "linkedin")
          .eq("product", "linkedin")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.linkedin.connected = !!(data as unknown[])?.[0];
      } catch {}

      // GMB (connected flag only; metrics handled later)
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status,resource_id")
          .eq("user_id", userId)
          .eq("provider", "google")
          .eq("source", "gmb")
          .eq("product", "gmb")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        const gmb0 = Array.isArray(data) ? (data as unknown[])[0] : null;
        out.gmb.connected = !!asRecord(gmb0)["resource_id"];
      } catch {}

      return out;
    }


// Ownership du site iNrCy : utile pour l'UI (rented => connexion globale "Suivi")
const { data: profileRow } = await supabase
  .from("profiles")
  .select("inrcy_site_ownership")
  .eq("user_id", userId)
  .maybeSingle();

const inrcySiteOwnership = String(asRecord(profileRow)["inrcy_site_ownership"] ?? "none");

    
// Load settings from the new schema:
// - site_inrcy -> inrcy_site_configs.settings
// - site_web -> pro_tools_configs.settings.site_web
const [inrcyCfgRes, proCfgRes] = await Promise.all([
  supabase.from("inrcy_site_configs").select("settings").eq("user_id", userId).maybeSingle(),
  supabase.from("pro_tools_configs").select("settings").eq("user_id", userId).maybeSingle(),
]);

// NOTE: SiteSettings has only optional fields, so an empty object is a valid fallback.
// Using `null` breaks TS in production builds (null not assignable to SiteSettings).
const inrcySettings = safeJsonParse<SiteSettings>(asRecord(inrcyCfgRes.data)["settings"], {});
const proSettings = safeJsonParse<Record<string, unknown>>(asRecord(proCfgRes.data)["settings"], {});

// Flag: en mode rented, on peut couper uniquement la couche iNrCy (sans débrancher GA4/GSC)
const inrcyTrackingEnabled = Boolean(asRecord(inrcySettings)["inrcy_tracking_enabled"] ?? true);

// ---- Cache (anti-quota Google) ----
// ⚠️ Correctif critique : la clé de cache DOIT dépendre de l'état des connexions.
// Sinon, après une déconnexion, on peut resservir un ancien payload (ex: GMB +90) jusqu'à expiration.
//
// On fabrique donc un "snapshot" léger des statuts, en lisant :
// - integrations (nouveau)
// - integrations_statistiques (legacy) si présent
async function buildConnectionsKey() {
  const keyParts: string[] = [];

  // 1) nouveau système
  try {
    const { data } = await supabase
      .from("integrations")
      .select("provider,source,product,status,resource_id,updated_at")
      .eq("user_id", userId);

    for (const r of (data as unknown[]) || []) {
      const rr = asRecord(r);
      const k = `${String(rr["provider"] ?? "")}:${String(rr["source"] ?? "")}:${String(rr["product"] ?? "")}`;
      const st = String(rr["status"] || "").toLowerCase();
      const rid = String(rr["resource_id"] || "");
      const ts = String(rr["updated_at"] || "");
      keyParts.push(`${k}=${st}|rid=${rid}@${ts}`);
    }
  } catch {
    // ignore
  }

  // 2) legacy (celui que tu vois dans Supabase : public.integrations_statistiques)
  try {
    const { data } = await supabase
      .from("integrations_statistiques")
      .select("fournisseur,source,produit,statut,identifiant")
      .eq("id_utilisateur", userId);

    for (const r of (data as unknown[]) || []) {
      const rr = asRecord(r);
      const prov = String(rr["fournisseur"] || "").toLowerCase();
      const src = String(rr["source"] || "").toLowerCase();
      const prod = String(rr["produit"] || "").toLowerCase();
      const st = String(rr["statut"] || "")
        .toLowerCase()
        .normalize("NFD")
        .replace(/\p{Diacritic}/gu, "");
      const id = String(rr["identifiant"] || "");
      keyParts.push(`legacy:${prov}:${src}:${prod}=${st}@${id}`);
    }
  } catch {
    // ignore if table doesn't exist
  }

  keyParts.sort();
  return keyParts.join("|") || "none";
}

const connectionsKey = await buildConnectionsKey();
const rangeKey = `days=${days}|include=${includeRaw || "all"}|inrcy=${inrcyTrackingEnabled ? 1 : 0}|conn=${connectionsKey}`;

// Lecture cache (best-effort)
try {
  const nowIso = new Date().toISOString();
  const { data: cacheHit } = await supabase
    .from("stats_cache")
    .select("payload, expires_at")
    .eq("user_id", userId)
    .eq("source", "overview")
    .eq("range_key", rangeKey)
    .gt("expires_at", nowIso)
    .order("expires_at", { ascending: false })
    .limit(1)
    .maybeSingle();
  if (asRecord(cacheHit)["payload"]) {
      const payload = asRecord(asRecord(cacheHit)["payload"]);
      // Rehydrate social connection flags to avoid stale/missing keys in cached payloads.
      try {
        const social = await fetchSocialStatus();
        payload["sources"] = { ...asRecord(payload["sources"]), ...social };
      } catch {}
      return NextResponse.json(payload);
  }
} catch {
  // Table stats_cache non présente ou non accessible : on ignore.
}

// Cache legacy (best-effort)
try {
  const { data: legacyHit } = await supabase
    .from("cache_statistiques")
    .select("charge_utile, cree_a")
    .eq("id_utilisateur", userId)
    .eq("source", "apercu")
    .eq("plage_cle", rangeKey)
    .order("cree_a", { ascending: false })
    .limit(1)
    .maybeSingle();

  if (asRecord(legacyHit)["charge_utile"]) {
    const payload = asRecord(asRecord(legacyHit)["charge_utile"]);
    // Rehydrate social connection flags to avoid stale/missing keys in legacy cached payloads.
    try {
      const social = await fetchSocialStatus();
      payload["sources"] = { ...asRecord(payload["sources"]), ...social };
    } catch {}
    return NextResponse.json(payload);
  }
} catch {
  // ignore
}

const proSiteWeb = asRecord(asRecord(proSettings)["site_web"]);
const proGa4 = asRecord(proSiteWeb["ga4"]);
const proGsc = asRecord(proSiteWeb["gsc"]);

const sources: Array<{ key: StatsSourceKey; ga4Property?: string; gscProperty?: string }> = [
  {
    key: "site_inrcy",
    ga4Property: (String(proGa4["property_id"] ?? "").trim() || undefined),
    gscProperty: (String(proGsc["property"] ?? "").trim() || undefined),
  },
];


    // Fetch each source
    const perSource: Record<string, { ga4: unknown | null; gsc: unknown | null; connected: SiteConn }> = {};
    const pageAgg = new Map<string, number>();
    const channelAgg = new Map<string, number>();
    const queryAgg = new Map<string, { clicks: number; impressions: number; positionSum: number; rows: number }>();

    let totalUsers = 0;
    let totalSessions = 0;
    let totalPageviews = 0;

    let engagementWeighted = 0; // engagementRate * sessions
    let durationWeighted = 0; // avgSessionDuration * sessions

    let totalClicks = 0;
    let totalImpressions = 0;

    for (const s of sources) {
      perSource[s.key] = { ga4: null, gsc: null, connected: { ga4: false, gsc: false } };

      const includeGa4 =
        includeAll || includeSet.has(`${s.key}_ga4`) || includeSet.has(`${s.key}-ga4`);
      const includeGsc =
        includeAll || includeSet.has(`${s.key}_gsc`) || includeSet.has(`${s.key}-gsc`);


      // GA4
      if (includeGa4 && s.ga4Property) {
        const token = await getGoogleTokenFor(s.key, "ga4");
        if (token?.accessToken) {
          perSource[s.key].connected.ga4 = true;

          const overview = await runGa4Report(token.accessToken, s.ga4Property, days);
          const pages = await runGa4TopPages(token.accessToken, s.ga4Property, days);
          const channels = await runGa4Channels(token.accessToken, s.ga4Property, days);

          perSource[s.key].ga4 = { propertyId: s.ga4Property, overview, pages, channels };

          if (includeGa4) totalUsers += overview.users;
          if (includeGa4) totalSessions += overview.sessions;
          if (includeGa4) totalPageviews += overview.pageviews;

          if (includeGa4) engagementWeighted += overview.engagementRate * overview.sessions;
          if (includeGa4) durationWeighted += overview.avgSessionDuration * overview.sessions;

          if (includeGa4) for (const p of pages) pageAgg.set(p.path, (pageAgg.get(p.path) || 0) + p.views);
          if (includeGa4) for (const c of channels) channelAgg.set(c.channel, (channelAgg.get(c.channel) || 0) + c.sessions);
        }
      }

      // GSC
      if (includeGsc && s.gscProperty) {
        const token = await getGoogleTokenFor(s.key, "gsc");
        if (token?.accessToken) {
          perSource[s.key].connected.gsc = true;

          const q = await runGscQuery(token.accessToken, s.gscProperty, days);
          perSource[s.key].gsc = { property: s.gscProperty, queries: q.rows };

          const rows = Array.isArray(asRecord(q)["rows"]) ? (asRecord(q)["rows"] as unknown[]) : [];
          for (const r of rows) {
            if (!includeGsc) continue;
            const rr = asRecord(r);
            const clicks = Number(rr["clicks"] ?? 0) || 0;
            const impressions = Number(rr["impressions"] ?? 0) || 0;
            const query = String(rr["query"] ?? "");
            const position = Number(rr["position"] ?? 0) || 0;

            totalClicks += clicks;
            totalImpressions += impressions;

            const cur = queryAgg.get(query) || { clicks: 0, impressions: 0, positionSum: 0, rows: 0 };
            cur.clicks += clicks;
            cur.impressions += impressions;
            cur.positionSum += position;
            cur.rows += 1;
            queryAgg.set(query, cur);
          }
        }
      }
    }

    const engagementRate = totalSessions > 0 ? engagementWeighted / totalSessions : 0;
    const avgSessionDuration = totalSessions > 0 ? durationWeighted / totalSessions : 0;
    const ctr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;

    const topPages = Array.from(pageAgg.entries())
      .map(([path, views]) => ({ path, views }))
      .sort((a, b) => b.views - a.views)
      .slice(0, 8);

    const channels = Array.from(channelAgg.entries())
      .map(([channel, sessions]) => ({ channel, sessions }))
      .sort((a, b) => b.sessions - a.sessions)
      .slice(0, 6);

    const topQueries = Array.from(queryAgg.entries())
      .map(([query, v]) => ({
        query,
        clicks: v.clicks,
        impressions: v.impressions,
        ctr: v.impressions > 0 ? v.clicks / v.impressions : 0,
        position: v.rows > 0 ? v.positionSum / v.rows : 0,
      }))
      .sort((a, b) => b.clicks - a.clicks)
      .slice(0, 8);

    // --- Connections + channel metrics ---
    const sourcesStatus: SourcesStatus = {
      site_inrcy: { connected: { ga4: false, gsc: false } },
      site_web: { connected: { ga4: false, gsc: false } },
      gmb: { connected: false, metrics: null },
      facebook: { connected: false, metrics: null },
      instagram: { connected: false, metrics: null },
      linkedin: { connected: false, metrics: null },
    };

    // copy site connections from perSource (built above)
    sourcesStatus.site_inrcy.connected = (asRecord(asRecord(perSource)["site_inrcy"])["connected"] as SiteConn) || { ga4: false, gsc: false };
    sourcesStatus.site_web.connected = (asRecord(asRecord(perSource)["site_web"])["connected"] as SiteConn) || { ga4: false, gsc: false };

    // Facebook: connected if a page has been selected (resource_id)
    try {
      const { data: fbRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id,access_token_enc")
        .eq("user_id", userId)
        .eq("provider", "facebook")
        .eq("source", "facebook")
        .eq("product", "facebook")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const fbRow = asRecord(fbRowRows?.[0]);

sourcesStatus.facebook.connected = !!fbRowRows?.[0];

      // Real Facebook Page metrics (only if included)
      const includeFb = includeAll || includeSet.has("facebook");
      if (!includeFb) {
        sourcesStatus.facebook.metrics = null;
      } else if (fbRow["resource_id"] && fbRow["access_token_enc"]) {
        try {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          sourcesStatus.facebook.metrics = await fbFetchDailyInsights(
            tryDecryptToken(String(fbRow["access_token_enc"])) || "",
            String(fbRow["resource_id"]),
            start,
            end
          );
        } catch (e: unknown) {
          sourcesStatus.facebook.metrics = { error: (e instanceof Error ? e.message : String(e)) || "facebook insights fetch failed" };
        }
      } else {
        sourcesStatus.facebook.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Facebook")
          .eq("source", "facebook")
          .eq("produit", "facebook")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String(asRecord(l)["statut"] || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.facebook.connected = false;
      } catch {}
    } catch {}

    // Instagram: Meta family. Connected only once a profile is selected (resource_id).
    try {
      const { data: igRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id,access_token_enc")
        .eq("user_id", userId)
        .eq("provider", "instagram")
        .eq("source", "instagram")
        .eq("product", "instagram")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const igRow = asRecord(igRowRows?.[0]);

sourcesStatus.instagram.connected = !!asRecord(igRow)["resource_id"];

      // Real Instagram metrics (only if included)
      const includeIg = includeAll || includeSet.has("instagram");
      if (!includeIg) {
        sourcesStatus.instagram.metrics = null;
      } else if (igRow["resource_id"] && igRow["access_token_enc"]) {
        try {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          sourcesStatus.instagram.metrics = await igFetchDailyInsights(
            tryDecryptToken(String(igRow["access_token_enc"])) || "",
            String(igRow["resource_id"]),
            start,
            end
          );
        } catch (e: unknown) {
          sourcesStatus.instagram.metrics = { error: (e instanceof Error ? e.message : String(e)) || "instagram insights fetch failed" };
        }
      } else {
        sourcesStatus.instagram.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Instagram")
          .eq("source", "instagram")
          .eq("produit", "instagram")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String(asRecord(l)["statut"] || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.instagram.connected = false;
      } catch {}
    } catch {}

    // LinkedIn: connected if an OAuth row exists.
    try {
      const { data: liRowRows } = await supabase
        .from("integrations")
        .select("id,status,access_token_enc,meta")
        .eq("user_id", userId)
        .eq("provider", "linkedin")
        .eq("source", "linkedin")
        .eq("product", "linkedin")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const liRow = asRecord(liRowRows?.[0]);

sourcesStatus.linkedin.connected = !!liRowRows?.[0];

      // Real LinkedIn org share stats (only if included)
      const includeLi = includeAll || includeSet.has("linkedin");
      if (!includeLi) {
        sourcesStatus.linkedin.metrics = null;
      } else if (liRow["access_token_enc"]) {
        try {
          const meta = asRecord(liRow["meta"]);
          const orgUrn = String(meta["org_urn"] || "");
          if (!orgUrn) {
            sourcesStatus.linkedin.metrics = { error: "No organization selected (org_urn missing)" };
          } else {
            const end = new Date();
            const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
            sourcesStatus.linkedin.metrics = await liFetchOrgShareStats(
              tryDecryptToken(String(liRow["access_token_enc"])) || "",
              orgUrn,
              start,
              end
            );
          }
        } catch (e: unknown) {
          sourcesStatus.linkedin.metrics = { error: (e instanceof Error ? e.message : String(e)) || "linkedin analytics fetch failed" };
        }
      } else {
        sourcesStatus.linkedin.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "LinkedIn")
          .eq("source", "linkedin")
          .eq("produit", "linkedin")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String(asRecord(l)["statut"] || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.linkedin.connected = false;
      } catch {}
    } catch {}

    // GMB: the UI needs a stable "connected" flag like GA4/GSC.
    // We consider it connected if an OAuth row exists in integrations.
    // (We still *try* to fetch metrics, but a missing API enablement should not flip the badge back to "off".)
    try {
      const { data: gmbRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id")
        .eq("user_id", userId)
        .eq("provider", "google")
        .eq("source", "gmb")
        .eq("product", "gmb")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const gmbRow = asRecord(gmbRowRows?.[0]);

sourcesStatus.gmb.connected = !!gmbRowRows?.[0] && !!gmbRow["resource_id"];

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Google")
          .eq("source", "gmb")
          .eq("produit", "gmb")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String(asRecord(l)["statut"] || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.gmb.connected = false;
      } catch {}

      if (gmbRowRows?.[0]) {
        const includeGmb = includeAll || includeSet.has("gmb");
        if (!includeGmb) {
          // Do not fetch metrics when filtered out.
          sourcesStatus.gmb.metrics = null;
        } else {
        const tok = await getGoogleTokenForAnyGoogle("gmb", "gmb");
        const accessToken = tok?.accessToken;

        // IMPORTANT:
        // GMB metrics are tied to a *location* (establishment page), not the Google account.
        // So we only fetch metrics once a location has been explicitly selected and saved.
        // Never fallback to a token-row resource_id here, otherwise we can show stale metrics
        // even when the user hasn't selected a location in the UI.
        const loc = String(gmbRow["resource_id"] || "");

        if (accessToken && loc) {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          try {
            sourcesStatus.gmb.metrics = await gmbFetchDailyMetrics(accessToken, loc, start, end);
          } catch (e: unknown) {
            sourcesStatus.gmb.metrics = { error: (e instanceof Error ? e.message : String(e)) || "performance fetch failed", location: loc };
          }
        } else {
          // Connected account but not configured (no location selected yet).
          sourcesStatus.gmb.metrics = null;
        }
        }
      }
    } catch {}



    const payload = {
      days,
      selected: includeAll ? null : Array.from(includeSet),
      inrcySiteOwnership,
      totals: {
        users: totalUsers,
        sessions: totalSessions,
        pageviews: totalPageviews,
        engagementRate,
        avgSessionDuration,
        clicks: totalClicks,
        impressions: totalImpressions,
        ctr,
      },
      topPages,
      channels,
      topQueries,
      sources: sourcesStatus,
      note: "Sources connectées: site iNrCy (GA4/GSC), site web (GA4/GSC), GMB, Facebook, Instagram, LinkedIn.",
    };

    // cache write (best-effort)
try {
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000).toISOString();
  await supabase.from("stats_cache").insert({
    user_id: userId,
    source: "overview",
    range_key: rangeKey,
    payload,
    expires_at: expiresAt,
  });
} catch {}

// cache legacy write (best-effort)
try {
  await supabase.from("cache_statistiques").insert({
    id_utilisateur: userId,
    source: "apercu",
    plage_cle: rangeKey,
    charge_utile: payload,
  });
} catch {}

    return NextResponse.json(payload);
  } catch (e: unknown) {
    return NextResponse.json({ error: (e instanceof Error ? e.message : String(e)) || "Unknown error" }, { status: 500 });
  }
}