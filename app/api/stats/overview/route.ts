import { NextResponse } from "next/server";
import type { StatsSourceKey } from "@/lib/googleStats";
import { tryDecryptToken } from "@/lib/oauthCrypto";
function asRecord(v: unknown): Record<string, unknown> {
  return v && typeof v === "object" && !Array.isArray(v) ? (v as Record<string, unknown>) : {};
}

// NOTE: We lazy-import internal libs inside the handler to avoid returning an HTML error page
// when a dependency throws at module-evaluation time (e.g. cookies()/headers() scope issues).

function safeJsonParse<T>(s: unknown, fallback: T): T {
  if (!s) return fallback;
  try {
    if (typeof s === "string") return JSON.parse(s) as T;
    return s as T;
  } catch {
    return fallback;
  }
}

type SiteSettings = {
  ga4?: { property_id?: string; measurement_id?: string };
  gsc?: { property?: string };
  site_web?: {
    ga4?: { property_id?: string; measurement_id?: string };
    gsc?: { property?: string };
  };
};

function _sumMap<K extends string>(items: Array<{ key: K; value: number }>) {
  const m = new Map<K, number>();
  for (const it of items) m.set(it.key, (m.get(it.key) || 0) + it.value);
  return m;
}

export async function GET(request: Request) {
  try {
    // Lazy-import server helpers inside the request scope to avoid Next.js request-scope errors.
    const { createSupabaseServer } = await import("@/lib/supabaseServer");
    const {
      getGoogleTokenFor,
      runGa4Report,
      runGa4TopPages,
      runGa4Channels,
      runGscQuery,
      getGoogleTokenForAnyGoogle,
    } = await import("@/lib/googleStats");
    const { gmbFetchDailyMetrics } = await import("@/lib/googleBusiness");
    const { igFetchDailyInsights } = await import("@/lib/metaInsights");
    const { fbFetchDailyInsights } = await import("@/lib/facebookInsights");
    const { liFetchOrgShareStats } = await import("@/lib/linkedinAnalytics");

    const { searchParams } = new URL(request.url);
    const days = Math.min(Math.max(Number(searchParams.get("days") || 28), 7), 90);

    // Optional: filter which sources to aggregate.
    // Comma-separated keys:
    // - site_inrcy_ga4, site_inrcy_gsc
    // - site_web_ga4,  site_web_gsc
    // - gmb, facebook
    const includeRaw = (searchParams.get("include") || "").trim();
    const includeSet = new Set(
      includeRaw
        ? includeRaw
            .split(",")
            .map((s) => s.trim())
            .filter(Boolean)
        : []
    );
    const includeAll = includeSet.size === 0;

    const supabase = await createSupabaseServer();
    const { data: authData, error: authErr } = await supabase.auth.getUser();
    if (authErr || !authData?.user) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }
    const userId = authData.user.id;


    // --- Social connection snapshot (always computed live) ---
    // IMPORTANT: iNrStats calls the same overview endpoint with different `include=` values.
    // If we return a cached payload generated by an older version (or without social keys),
    // the UI can incorrectly show "Déconnecté" even when integrations are connected.
    // So we always (re)hydrate social connection flags from `integrations` before returning.
    async function fetchSocialStatus() {
      const out: Record<string, unknown> = {
        gmb: { connected: false, metrics: null },
        facebook: { connected: false },
        instagram: { connected: false },
        linkedin: { connected: false },
      };

      // Facebook
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status")
          .eq("user_id", userId)
          .eq("provider", "facebook")
          .eq("source", "facebook")
          .eq("product", "facebook")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.facebook.connected = !!(data as unknown[])?.[0];
      } catch {}

      // Instagram (requires profile selection => resource_id)
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status,resource_id")
          .eq("user_id", userId)
          .eq("provider", "instagram")
          .eq("source", "instagram")
          .eq("product", "instagram")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.instagram.connected = !!(data as unknown[])?.[0]?.resource_id;
      } catch {}

      // LinkedIn
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status")
          .eq("user_id", userId)
          .eq("provider", "linkedin")
          .eq("source", "linkedin")
          .eq("product", "linkedin")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.linkedin.connected = !!(data as unknown[])?.[0];
      } catch {}

      // GMB (connected flag only; metrics handled later)
      try {
        const { data } = await supabase
          .from("integrations")
          .select("id,status,resource_id")
          .eq("user_id", userId)
          .eq("provider", "google")
          .eq("source", "gmb")
          .eq("product", "gmb")
          .eq("status", "connected")
          .order("updated_at", { ascending: false })
          .order("created_at", { ascending: false })
          .limit(1);
        out.gmb.connected = !!(data as unknown[])?.[0]?.resource_id;
      } catch {}

      return out;
    }


// Ownership du site iNrCy : utile pour l'UI (rented => connexion globale "Suivi")
const { data: profileRow } = await supabase
  .from("profiles")
  .select("inrcy_site_ownership")
  .eq("user_id", userId)
  .maybeSingle();

const inrcySiteOwnership = String((profileRow as unknown)?.inrcy_site_ownership || "none");

    
// Load settings from the new schema:
// - site_inrcy -> inrcy_site_configs.settings
// - site_web -> pro_tools_configs.settings.site_web
const [inrcyCfgRes, proCfgRes] = await Promise.all([
  supabase.from("inrcy_site_configs").select("settings").eq("user_id", userId).maybeSingle(),
  supabase.from("pro_tools_configs").select("settings").eq("user_id", userId).maybeSingle(),
]);

// NOTE: SiteSettings has only optional fields, so an empty object is a valid fallback.
// Using `null` breaks TS in production builds (null not assignable to SiteSettings).
const inrcySettings = safeJsonParse<SiteSettings>((inrcyCfgRes.data as unknown)?.settings, {});
const proSettings = safeJsonParse<unknown>((proCfgRes.data as unknown)?.settings, {});

// Flag: en mode rented, on peut couper uniquement la couche iNrCy (sans débrancher GA4/GSC)
const inrcyTrackingEnabled = Boolean((inrcySettings as unknown)?.inrcy_tracking_enabled ?? true);

// ---- Cache (anti-quota Google) ----
// ⚠️ Correctif critique : la clé de cache DOIT dépendre de l'état des connexions.
// Sinon, après une déconnexion, on peut resservir un ancien payload (ex: GMB +90) jusqu'à expiration.
//
// On fabrique donc un "snapshot" léger des statuts, en lisant :
// - integrations (nouveau)
// - integrations_statistiques (legacy) si présent
async function buildConnectionsKey() {
  const keyParts: string[] = [];

  // 1) nouveau système
  try {
    const { data } = await supabase
      .from("integrations")
      .select("provider,source,product,status,resource_id,updated_at")
      .eq("user_id", userId);

    for (const r of (data as unknown[]) || []) {
      const k = `${r.provider}:${r.source}:${r.product}`;
      const st = String(r.status || "").toLowerCase();
      const rid = String(r.resource_id || "");
      const ts = String(r.updated_at || "");
      keyParts.push(`${k}=${st}|rid=${rid}@${ts}`);
    }
  } catch {
    // ignore
  }

  // 2) legacy (celui que tu vois dans Supabase : public.integrations_statistiques)
  try {
    const { data } = await supabase
      .from("integrations_statistiques")
      .select("fournisseur,source,produit,statut,identifiant")
      .eq("id_utilisateur", userId);

    for (const r of (data as unknown[]) || []) {
      const prov = String(r.fournisseur || "").toLowerCase();
      const src = String(r.source || "").toLowerCase();
      const prod = String(r.produit || "").toLowerCase();
      const st = String(r.statut || "")
        .toLowerCase()
        .normalize("NFD")
        .replace(/\p{Diacritic}/gu, "");
      const id = String(r.identifiant || "");
      keyParts.push(`legacy:${prov}:${src}:${prod}=${st}@${id}`);
    }
  } catch {
    // ignore if table doesn't exist
  }

  keyParts.sort();
  return keyParts.join("|") || "none";
}

const connectionsKey = await buildConnectionsKey();
const rangeKey = `days=${days}|include=${includeRaw || "all"}|inrcy=${inrcyTrackingEnabled ? 1 : 0}|conn=${connectionsKey}`;

// Lecture cache (best-effort)
try {
  const nowIso = new Date().toISOString();
  const { data: cacheHit } = await supabase
    .from("stats_cache")
    .select("payload, expires_at")
    .eq("user_id", userId)
    .eq("source", "overview")
    .eq("range_key", rangeKey)
    .gt("expires_at", nowIso)
    .order("expires_at", { ascending: false })
    .limit(1)
    .maybeSingle();
  if ((cacheHit as unknown)?.payload) {
      const payload = asRecord(cacheHit)["payload"] as unknown;
      // Rehydrate social connection flags to avoid stale/missing keys in cached payloads.
      try {
        const social = await fetchSocialStatus();
        payload.sources = { ...(payload.sources || {}), ...social };
      } catch {}
      return NextResponse.json(payload);
  }
} catch {
  // Table stats_cache non présente ou non accessible : on ignore.
}

// Cache legacy (best-effort)
try {
  const { data: legacyHit } = await supabase
    .from("cache_statistiques")
    .select("charge_utile, cree_a")
    .eq("id_utilisateur", userId)
    .eq("source", "apercu")
    .eq("plage_cle", rangeKey)
    .order("cree_a", { ascending: false })
    .limit(1)
    .maybeSingle();

  if ((legacyHit as unknown)?.charge_utile) {
    const payload = asRecord(legacyHit)["charge_utile"] as unknown;
    // Rehydrate social connection flags to avoid stale/missing keys in legacy cached payloads.
    try {
      const social = await fetchSocialStatus();
      payload.sources = { ...(payload.sources || {}), ...social };
    } catch {}
    return NextResponse.json(payload);
  }
} catch {
  // ignore
}

const sources: Array<{ key: StatsSourceKey; ga4Property?: string; gscProperty?: string }> = [
  {
    key: "site_inrcy",
    ga4Property: inrcyTrackingEnabled ? (inrcySettings as unknown)?.ga4?.property_id : undefined,
    gscProperty: inrcyTrackingEnabled ? (inrcySettings as unknown)?.gsc?.property : undefined,
  },
  {
    key: "site_web",
    ga4Property: (proSettings as unknown)?.site_web?.ga4?.property_id,
    gscProperty: (proSettings as unknown)?.site_web?.gsc?.property,
  },
];


    // Fetch each source
    const perSource: Record<string, unknown> = {};
    const pageAgg = new Map<string, number>();
    const channelAgg = new Map<string, number>();
    const queryAgg = new Map<string, { clicks: number; impressions: number; positionSum: number; rows: number }>();

    let totalUsers = 0;
    let totalSessions = 0;
    let totalPageviews = 0;

    let engagementWeighted = 0; // engagementRate * sessions
    let durationWeighted = 0; // avgSessionDuration * sessions

    let totalClicks = 0;
    let totalImpressions = 0;

    for (const s of sources) {
      perSource[s.key] = { ga4: null, gsc: null, connected: { ga4: false, gsc: false } };

      const includeGa4 =
        includeAll || includeSet.has(`${s.key}_ga4`) || includeSet.has(`${s.key}-ga4`);
      const includeGsc =
        includeAll || includeSet.has(`${s.key}_gsc`) || includeSet.has(`${s.key}-gsc`);


      // GA4
      if (includeGa4 && s.ga4Property) {
        const token = await getGoogleTokenFor(s.key, "ga4");
        if (token?.accessToken) {
          perSource[s.key].connected.ga4 = true;

          const overview = await runGa4Report(token.accessToken, s.ga4Property, days);
          const pages = await runGa4TopPages(token.accessToken, s.ga4Property, days);
          const channels = await runGa4Channels(token.accessToken, s.ga4Property, days);

          perSource[s.key].ga4 = { propertyId: s.ga4Property, overview, pages, channels };

          if (includeGa4) totalUsers += overview.users;
          if (includeGa4) totalSessions += overview.sessions;
          if (includeGa4) totalPageviews += overview.pageviews;

          if (includeGa4) engagementWeighted += overview.engagementRate * overview.sessions;
          if (includeGa4) durationWeighted += overview.avgSessionDuration * overview.sessions;

          if (includeGa4) for (const p of pages) pageAgg.set(p.path, (pageAgg.get(p.path) || 0) + p.views);
          if (includeGa4) for (const c of channels) channelAgg.set(c.channel, (channelAgg.get(c.channel) || 0) + c.sessions);
        }
      }

      // GSC
      if (includeGsc && s.gscProperty) {
        const token = await getGoogleTokenFor(s.key, "gsc");
        if (token?.accessToken) {
          perSource[s.key].connected.gsc = true;

          const q = await runGscQuery(token.accessToken, s.gscProperty, days);
          perSource[s.key].gsc = { property: s.gscProperty, queries: q.rows };

          for (const r of q.rows) {
            if (!includeGsc) continue;
            totalClicks += r.clicks;
            totalImpressions += r.impressions;

            const cur = queryAgg.get(r.query) || { clicks: 0, impressions: 0, positionSum: 0, rows: 0 };
            cur.clicks += r.clicks;
            cur.impressions += r.impressions;
            cur.positionSum += r.position;
            cur.rows += 1;
            queryAgg.set(r.query, cur);
          }
        }
      }
    }

    const engagementRate = totalSessions > 0 ? engagementWeighted / totalSessions : 0;
    const avgSessionDuration = totalSessions > 0 ? durationWeighted / totalSessions : 0;
    const ctr = totalImpressions > 0 ? totalClicks / totalImpressions : 0;

    const topPages = Array.from(pageAgg.entries())
      .map(([path, views]) => ({ path, views }))
      .sort((a, b) => b.views - a.views)
      .slice(0, 8);

    const channels = Array.from(channelAgg.entries())
      .map(([channel, sessions]) => ({ channel, sessions }))
      .sort((a, b) => b.sessions - a.sessions)
      .slice(0, 6);

    const topQueries = Array.from(queryAgg.entries())
      .map(([query, v]) => ({
        query,
        clicks: v.clicks,
        impressions: v.impressions,
        ctr: v.impressions > 0 ? v.clicks / v.impressions : 0,
        position: v.rows > 0 ? v.positionSum / v.rows : 0,
      }))
      .sort((a, b) => b.clicks - a.clicks)
      .slice(0, 8);

    // --- Connections + channel metrics ---
    const sourcesStatus: Record<string, unknown> = {
      site_inrcy: { connected: { ga4: false, gsc: false } },
      site_web: { connected: { ga4: false, gsc: false } },
      gmb: { connected: false, metrics: null },
      facebook: { connected: false, metrics: null },
      instagram: { connected: false, metrics: null },
      linkedin: { connected: false, metrics: null },
    };

    // copy site connections from perSource (built above)
    sourcesStatus.site_inrcy.connected = perSource.site_inrcy?.connected || { ga4: false, gsc: false };
    sourcesStatus.site_web.connected = perSource.site_web?.connected || { ga4: false, gsc: false };

    // Facebook: connected if a page has been selected (resource_id)
    try {
      const { data: fbRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id,access_token_enc")
        .eq("user_id", userId)
        .eq("provider", "facebook")
        .eq("source", "facebook")
        .eq("product", "facebook")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const fbRow = fbRowRows?.[0] as unknown;

sourcesStatus.facebook.connected = !!fbRow;

      // Real Facebook Page metrics (only if included)
      const includeFb = includeAll || includeSet.has("facebook");
      if (!includeFb) {
        sourcesStatus.facebook.metrics = null;
      } else if (fbRow?.resource_id && fbRow?.access_token_enc) {
        try {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          sourcesStatus.facebook.metrics = await fbFetchDailyInsights(
            tryDecryptToken(String(fbRow.access_token_enc)) || "",
            String(fbRow.resource_id),
            start,
            end
          );
        } catch (e: unknown) {
          sourcesStatus.facebook.metrics = { error: e?.message || "facebook insights fetch failed" };
        }
      } else {
        sourcesStatus.facebook.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Facebook")
          .eq("source", "facebook")
          .eq("produit", "facebook")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String((l as unknown)?.statut || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.facebook.connected = false;
      } catch {}
    } catch {}

    // Instagram: Meta family. Connected only once a profile is selected (resource_id).
    try {
      const { data: igRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id,access_token_enc")
        .eq("user_id", userId)
        .eq("provider", "instagram")
        .eq("source", "instagram")
        .eq("product", "instagram")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const igRow = igRowRows?.[0] as unknown;

sourcesStatus.instagram.connected = !!igRow?.resource_id;

      // Real Instagram metrics (only if included)
      const includeIg = includeAll || includeSet.has("instagram");
      if (!includeIg) {
        sourcesStatus.instagram.metrics = null;
      } else if (igRow?.resource_id && igRow?.access_token_enc) {
        try {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          sourcesStatus.instagram.metrics = await igFetchDailyInsights(
            tryDecryptToken(String(igRow.access_token_enc)) || "",
            String(igRow.resource_id),
            start,
            end
          );
        } catch (e: unknown) {
          sourcesStatus.instagram.metrics = { error: e?.message || "instagram insights fetch failed" };
        }
      } else {
        sourcesStatus.instagram.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Instagram")
          .eq("source", "instagram")
          .eq("produit", "instagram")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String((l as unknown)?.statut || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.instagram.connected = false;
      } catch {}
    } catch {}

    // LinkedIn: connected if an OAuth row exists.
    try {
      const { data: liRowRows } = await supabase
        .from("integrations")
        .select("id,status,access_token_enc,meta")
        .eq("user_id", userId)
        .eq("provider", "linkedin")
        .eq("source", "linkedin")
        .eq("product", "linkedin")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const liRow = liRowRows?.[0] as unknown;

sourcesStatus.linkedin.connected = !!liRow;

      // Real LinkedIn org share stats (only if included)
      const includeLi = includeAll || includeSet.has("linkedin");
      if (!includeLi) {
        sourcesStatus.linkedin.metrics = null;
      } else if (liRow?.access_token_enc) {
        try {
          const meta = (liRow as unknown)?.meta || {};
          const orgUrn = String(meta?.org_urn || "");
          if (!orgUrn) {
            sourcesStatus.linkedin.metrics = { error: "No organization selected (org_urn missing)" };
          } else {
            const end = new Date();
            const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
            sourcesStatus.linkedin.metrics = await liFetchOrgShareStats(
              tryDecryptToken(String(liRow.access_token_enc)) || "",
              orgUrn,
              start,
              end
            );
          }
        } catch (e: unknown) {
          sourcesStatus.linkedin.metrics = { error: e?.message || "linkedin analytics fetch failed" };
        }
      } else {
        sourcesStatus.linkedin.metrics = null;
      }

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "LinkedIn")
          .eq("source", "linkedin")
          .eq("produit", "linkedin")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String((l as unknown)?.statut || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.linkedin.connected = false;
      } catch {}
    } catch {}

    // GMB: the UI needs a stable "connected" flag like GA4/GSC.
    // We consider it connected if an OAuth row exists in integrations.
    // (We still *try* to fetch metrics, but a missing API enablement should not flip the badge back to "off".)
    try {
      const { data: gmbRowRows } = await supabase
        .from("integrations")
        .select("id,status,resource_id")
        .eq("user_id", userId)
        .eq("provider", "google")
        .eq("source", "gmb")
        .eq("product", "gmb")
        .eq("status", "connected")
        .order("updated_at", { ascending: false })
        .order("created_at", { ascending: false })
        .limit(1);
      const gmbRow = gmbRowRows?.[0] as unknown;

sourcesStatus.gmb.connected = !!gmbRow?.resource_id;

      // Legacy override
      try {
        const { data: l } = await supabase
          .from("integrations_statistiques")
          .select("statut")
          .eq("id_utilisateur", userId)
          .eq("fournisseur", "Google")
          .eq("source", "gmb")
          .eq("produit", "gmb")
          .order("identifiant", { ascending: false })
          .limit(1)
          .maybeSingle();
        const st = String((l as unknown)?.statut || "")
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");
        if (st.includes("deconnect") || st.includes("disconnected")) sourcesStatus.gmb.connected = false;
      } catch {}

      if (gmbRow) {
        const includeGmb = includeAll || includeSet.has("gmb");
        if (!includeGmb) {
          // Do not fetch metrics when filtered out.
          sourcesStatus.gmb.metrics = null;
        } else {
        const tok = await getGoogleTokenForAnyGoogle("gmb", "gmb");
        const accessToken = tok?.accessToken;

        // IMPORTANT:
        // GMB metrics are tied to a *location* (establishment page), not the Google account.
        // So we only fetch metrics once a location has been explicitly selected and saved.
        // Never fallback to a token-row resource_id here, otherwise we can show stale metrics
        // even when the user hasn't selected a location in the UI.
        const loc = gmbRow?.resource_id;

        if (accessToken && loc) {
          const end = new Date();
          const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
          try {
            sourcesStatus.gmb.metrics = await gmbFetchDailyMetrics(accessToken, loc, start, end);
          } catch (e: unknown) {
            sourcesStatus.gmb.metrics = { error: e?.message || "performance fetch failed", location: loc };
          }
        } else {
          // Connected account but not configured (no location selected yet).
          sourcesStatus.gmb.metrics = null;
        }
        }
      }
    } catch {}



    const payload = {
      days,
      selected: includeAll ? null : Array.from(includeSet),
      inrcySiteOwnership,
      totals: {
        users: totalUsers,
        sessions: totalSessions,
        pageviews: totalPageviews,
        engagementRate,
        avgSessionDuration,
        clicks: totalClicks,
        impressions: totalImpressions,
        ctr,
      },
      topPages,
      channels,
      topQueries,
      sources: sourcesStatus,
      note: "Sources connectées: site iNrCy (GA4/GSC), site web (GA4/GSC), GMB, Facebook, Instagram, LinkedIn.",
    };

    // cache write (best-effort)
try {
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000).toISOString();
  await supabase.from("stats_cache").insert({
    user_id: userId,
    source: "overview",
    range_key: rangeKey,
    payload,
    expires_at: expiresAt,
  });
} catch {}

// cache legacy write (best-effort)
try {
  await supabase.from("cache_statistiques").insert({
    id_utilisateur: userId,
    source: "apercu",
    plage_cle: rangeKey,
    charge_utile: payload,
  });
} catch {}

    return NextResponse.json(payload);
  } catch (e: unknown) {
    return NextResponse.json({ error: e?.message || "Unknown error" }, { status: 500 });
  }
}